<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android - Behavior · dangxy99的Blog</title><meta name="description" content="Android - Behavior - dangxy"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="dangxy99的Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/dangxy" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android - Behavior</h1><div class="post-info">Apr 1, 2017</div><div class="post-content"><h3 id="Behaivor"><a href="#Behaivor" class="headerlink" title="Behaivor"></a>Behaivor</h3><p>Behavior只有是CoordinatorLayout的直接子View才有意义。只要将Behavior绑定到CoordinatorLayout的直接子元素上，就能对触摸事件（touch events）、window insets、measurement、layout以及嵌套滚动（nested scrolling）等动作进行拦截。Design Library的大多功能都是借助Behavior的大量运用来实现的。当然，Behavior无法独立完成工作，必须与实际调用的CoordinatorLayout子视图相绑定。具体有三种方式：通过代码绑定、在XML中绑定或者通过注释实现自动绑定。上面NestedScrollView中app:layout_behavior=”@string/appbar_scrolling_view_behavior”的Behavior是系统默认的，我们也可以根据自己的需求来自定义Behavior。<br><a id="more"></a></p>
<h3 id="自定义Behavior"><a href="#自定义Behavior" class="headerlink" title="自定义Behavior"></a>自定义Behavior</h3><ul>
<li>某个view监听另一个view的状态变化，例如大小、位置、显示状态等<br>需要关系：layoutDependsOn和onDependentViewChanged方法， </li>
<li>某个view监听CoordinatorLayout里的滑动状态<br>需要关系：onStartNestedScroll和onNestedPreScroll方法<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * 表示是否给应用了Behavior 的View 指定一个依赖的布局，通常，当依赖的View 布局发生变化时</div><div class="line">     * 不管被被依赖View 的顺序怎样，被依赖的View也会重新布局</div><div class="line">     * <span class="doctag">@param</span> parent</div><div class="line">     * <span class="doctag">@param</span> child 绑定behavior 的View</div><div class="line">     * <span class="doctag">@param</span> dependency   依赖的view</div><div class="line">     * <span class="doctag">@return</span> 如果child 是依赖的指定的View 返回true,否则返回false</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">layoutDependsOn</span><span class="params">(CoordinatorLayout parent, View child, View dependency)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.layoutDependsOn(parent, child, dependency);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 当被依赖的View 状态（如：位置、大小）发生变化时，这个方法被调用</div><div class="line">     * <span class="doctag">@param</span> parent</div><div class="line">     * <span class="doctag">@param</span> child</div><div class="line">     * <span class="doctag">@param</span> dependency</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDependentViewChanged</span><span class="params">(CoordinatorLayout parent, View child, View dependency)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onDependentViewChanged(parent, child, dependency);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  当coordinatorLayout 的子View试图开始嵌套滑动的时候被调用。当返回值为true的时候表明</div><div class="line">     *  coordinatorLayout 充当nested scroll parent 处理这次滑动，需要注意的是只有当返回值为true</div><div class="line">     *  的时候，Behavior 才能收到后面的一些nested scroll 事件回调（如：onNestedPreScroll、onNestedScroll等）</div><div class="line">     *  这个方法有个重要的参数nestedScrollAxes，表明处理的滑动的方向。</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> coordinatorLayout 和Behavior 绑定的View的父CoordinatorLayout</div><div class="line">     * <span class="doctag">@param</span> child  和Behavior 绑定的View</div><div class="line">     * <span class="doctag">@param</span> directTargetChild</div><div class="line">     * <span class="doctag">@param</span> target</div><div class="line">     * <span class="doctag">@param</span> nestedScrollAxes 嵌套滑动 应用的滑动方向，看 &#123;<span class="doctag">@link</span> ViewCompat#SCROLL_AXIS_HORIZONTAL&#125;,</div><div class="line">     *                         &#123;<span class="doctag">@link</span> ViewCompat#SCROLL_AXIS_VERTICAL&#125;</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartNestedScroll(coordinatorLayout, child, directTargetChild, target, nestedScrollAxes);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 嵌套滚动发生之前被调用</div><div class="line">     * 在nested scroll child 消费掉自己的滚动距离之前，嵌套滚动每次被nested scroll child</div><div class="line">     * 更新都会调用onNestedPreScroll。注意有个重要的参数consumed，可以修改这个数组表示你消费</div><div class="line">     * 了多少距离。假设用户滑动了100px,child 做了90px 的位移，你需要把 consumed［1］的值改成90，</div><div class="line">     * 这样coordinatorLayout就能知道只处理剩下的10px的滚动。</div><div class="line">     * <span class="doctag">@param</span> coordinatorLayout</div><div class="line">     * <span class="doctag">@param</span> child</div><div class="line">     * <span class="doctag">@param</span> target</div><div class="line">     * <span class="doctag">@param</span> dx  用户水平方向的滚动距离</div><div class="line">     * <span class="doctag">@param</span> dy  用户竖直方向的滚动距离</div><div class="line">     * <span class="doctag">@param</span> consumed</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(CoordinatorLayout coordinatorLayout, View child, View target, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 进行嵌套滚动时被调用</div><div class="line">     * <span class="doctag">@param</span> coordinatorLayout</div><div class="line">     * <span class="doctag">@param</span> child</div><div class="line">     * <span class="doctag">@param</span> target</div><div class="line">     * <span class="doctag">@param</span> dxConsumed target 已经消费的x方向的距离</div><div class="line">     * <span class="doctag">@param</span> dyConsumed target 已经消费的y方向的距离</div><div class="line">     * <span class="doctag">@param</span> dxUnconsumed x 方向剩下的滚动距离</div><div class="line">     * <span class="doctag">@param</span> dyUnconsumed y 方向剩下的滚动距离</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(CoordinatorLayout coordinatorLayout, View child, View target, <span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed, <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  嵌套滚动结束时被调用，这是一个清除滚动状态等的好时机。</div><div class="line">     * <span class="doctag">@param</span> coordinatorLayout</div><div class="line">     * <span class="doctag">@param</span> child</div><div class="line">     * <span class="doctag">@param</span> target</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStopNestedScroll</span><span class="params">(CoordinatorLayout coordinatorLayout, View child, View target)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onStopNestedScroll(coordinatorLayout, child, target);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * onStartNestedScroll返回true才会触发这个方法，接受滚动处理后回调，可以在这个</div><div class="line">     * 方法里做一些准备工作，如一些状态的重置等。</div><div class="line">     * <span class="doctag">@param</span> coordinatorLayout</div><div class="line">     * <span class="doctag">@param</span> child</div><div class="line">     * <span class="doctag">@param</span> directTargetChild</div><div class="line">     * <span class="doctag">@param</span> target</div><div class="line">     * <span class="doctag">@param</span> nestedScrollAxes</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScrollAccepted</span><span class="params">(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onNestedScrollAccepted(coordinatorLayout, child, directTargetChild, target, nestedScrollAxes);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 用户松开手指并且会发生惯性动作之前调用，参数提供了速度信息，可以根据这些速度信息</div><div class="line">     * 决定最终状态，比如滚动Header，是让Header处于展开状态还是折叠状态。返回true 表</div><div class="line">     * 示消费了fling.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> coordinatorLayout</div><div class="line">     * <span class="doctag">@param</span> child</div><div class="line">     * <span class="doctag">@param</span> target</div><div class="line">     * <span class="doctag">@param</span> velocityX x 方向的速度</div><div class="line">     * <span class="doctag">@param</span> velocityY y 方向的速度</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onNestedPreFling</span><span class="params">(CoordinatorLayout coordinatorLayout, View child, View target, <span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onNestedPreFling(coordinatorLayout, child, target, velocityX, velocityY);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//可以重写这个方法对子View 进行重新布局</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onLayoutChild</span><span class="params">(CoordinatorLayout parent, View child, <span class="keyword">int</span> layoutDirection)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onLayoutChild(parent, child, layoutDirection);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2017/04/15/Android - CoordinatorLayout Behavior/" class="prev">上一篇</a><a href="/2017/03/15/Android-Retrofit&amp;Rxjava的结合/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2020 <a href="http://yoursite.com">dangxy</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>
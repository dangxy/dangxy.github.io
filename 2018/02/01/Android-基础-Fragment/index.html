<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android 基础-Fragment · 党学义的博客</title><meta name="description" content="Android 基础-Fragment - dangxy"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="党学义的博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/categories/" target="_self" class="nav-list-link">CATEGORIES</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">TAGS</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/dangxy" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android 基础-Fragment</h1><div class="post-info">Feb 1, 2018</div><div class="post-content"><h2 id="四大组件-Fragment"><a href="#四大组件-Fragment" class="headerlink" title="四大组件/Fragment"></a>四大组件/Fragment</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>引入整个support-v4库，则<br><code>compile &#39;com.android.support:support-v4:24.2.1&#39;</code>，<br>如果只想引入support-fragment库，则<br><code>com.android.support:support-fragment:24.2.1</code>。<br>Fragment是依赖于Activity的，不能独立存在的。</p>
<a id="more"></a>
<ul>
<li>一个Activity里可以有多个Fragment。</li>
<li>一个Fragment可以被多个Activity重用。</li>
<li>Fragment有自己的生命周期，并能接收输入事件。</li>
<li>我们能在Activity运行时动态地添加或删除Fragment。</li>
</ul>
<h3 id="Fragment-核心类"><a href="#Fragment-核心类" class="headerlink" title="Fragment 核心类"></a>Fragment 核心类</h3><ol>
<li>Fragment：Fragment的基类，任何创建的Fragment都需要继承该类.</li>
<li>FragmentManager：管理和维护Fragment。他是抽象类，具体的实现类是FragmentManagerImpl.</li>
<li>FragmentTransaction：对Fragment的添加、删除等操作都需要通过事务方式进行。他是抽象类，具体的实现类是BackStackRecord。</li>
<li>Fragment有很多可以复写的方法，其中最常用的就是onCreateView()，该方法返回Fragment的UI布局，需要注意的是inflate()的第三个参数是false，因为在Fragment内部实现中，会把该布局添加到container中，如果设为true，那么就会重复做两次添加，则会抛如下异常：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Caused by: java.lang.IllegalStateException: The specified child already has a parent. You must call removeView() on the child&apos;s parent first.</div></pre></td></tr></table></figure>
<h3 id="ViewPager-Fragment相关"><a href="#ViewPager-Fragment相关" class="headerlink" title="ViewPager+Fragment相关"></a>ViewPager+Fragment相关</h3><ol>
<li>ViewPager是support v4库中提供界面滑动的类，继承自ViewGroup。PagerAdapter是ViewPager的适配器类，为ViewPager提供界面。但是一般来说，通常都会使用PagerAdapter的两个子类：FragmentPagerAdapter和FragmentStatePagerAdapter作为ViewPager的适配器，他们的特点是界面是Fragment。</li>
</ol>
<blockquote>
<p>在support v13和support v4中都提供了FragmentPagerAdapter和FragmentStatePagerAdapter，区别在于：support v13中使用android.app.Fragment，而support v4使用android.support.v4.app.Fragment。一般都使用support v4中的FragmentPagerAdapter和FragmentStatePagerAdapter。  </p>
</blockquote>
<ol>
<li>FragmentPagerAdapter和FragmentStatePagerAdapter需要重写的方法都一样，常见的重写方法如下：</li>
</ol>
<ul>
<li>public FragmentPagerAdapter(FragmentManager fm): 构造函数，参数为FragmentManager。如果是嵌套Fragment场景，子 PagerAdapter的参数传入getChildFragmentManager()。</li>
<li>Fragment getItem(int position): 返回第position位置的Fragment，必须重写。</li>
<li>int getCount(): 返回ViewPager的页数，必须重写。</li>
<li>Object instantiateItem(ViewGroup container, int position): container是ViewPager对象，返回第position位置的Fragment。</li>
<li>void destroyItem(ViewGroup container, int position, Object object): container是ViewPager对象，object是Fragment对象。</li>
<li>getItemPosition(Object object): object是Fragment对象，如果返回POSITION_UNCHANGED，则表示当前Fragment不刷新，如果返回POSITION_NONE，则表示当前Fragment需要调用destroyItem()和instantiateItem()进行销毁和重建。 默认情况下返回POSITION_UNCHANGED。</li>
</ul>
<h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><ol>
<li>懒加载主要用于ViewPager且每页是Fragment的情况，场景为微信主界面，底部有4个tab，当滑到另一个tab时，先显示”正在加载”，过一会才会显示正常界面。</li>
<li>默认情况，ViewPager会缓存当前页和左右相邻的界面。实现懒加载的主要原因是：用户没进入的界面需要有一系列的网络、数据库等耗资源、耗时的操作，预先做这些数据加载是不必要的。</li>
<li>这里懒加载的实现思路是：用户不可见的界面，只初始化UI，但是不会做任何数据加载。等滑到该页，才会异步做数据加载并更新UI。</li>
<li>这里就实现类似微信那种效果，整个UI布局为：底部用PagerBottomTabStrip(<a href="https://github.com/tyzlmjj/PagerBottomTabStrip)项目实现，上面是ViewPager，使用FragmentPagerAdapter。逻辑为：当用户滑到另一个界面，首先会显示正在加载，等数据加载完毕后（这里用睡眠1秒钟代替）显示正常界面。" target="_blank" rel="external">https://github.com/tyzlmjj/PagerBottomTabStrip)项目实现，上面是ViewPager，使用FragmentPagerAdapter。逻辑为：当用户滑到另一个界面，首先会显示正在加载，等数据加载完毕后（这里用睡眠1秒钟代替）显示正常界面。</a></li>
<li>ViewPager默认缓存左右相邻界面，为了避免不必要的重新数据加载（重复调用onCreateView()），因为有4个tab，因此将离线缓存的半径设置为3，即setOffscreenPageLimit(3)。</li>
<li>懒加载主要依赖Fragment的setUserVisibleHint(boolean isVisible)方法，当Fragment变为可见时，会调用setUserVisibleHint(true)；当Fragment变为不可见时，会调用setUserVisibleHint(false)，且该方法调用时机：</li>
</ol>
<ul>
<li>onAttach()之前，调用setUserVisibleHint(false)。</li>
<li>onCreateView()之前，如果该界面为当前页，则调用setUserVisibleHint(true)，否则调用setUserVisibleHint(false)。</li>
<li>界面变为可见时，调用setUserVisibleHint(true)。</li>
<li>界面变为不可见时，调用setUserVisibleHint(false)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;    <span class="keyword">private</span> View mRootView;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mIsInited;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mIsPrepared;    </div><div class="line">	  <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        mRootView = inflater.inflate(R.layout.fragment_lazy, container, <span class="keyword">false</span>);</div><div class="line">        mIsPrepared = <span class="keyword">true</span>;</div><div class="line">        lazyLoad();</div><div class="line">            <span class="keyword">return</span> mRootView;</div><div class="line">    &#125;</div><div class="line">            </div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lazyLoad</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (getUserVisibleHint() &amp;&amp; mIsPrepared &amp;&amp; !mIsInited) &#123; </div><div class="line">               <span class="comment">//异步初始化，在初始化后显示正常UI</span></div><div class="line">            loadData();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">               </div><div class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span> </span>&#123;</div><div class="line">         <span class="keyword">new</span> Thread() &#123;</div><div class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">//1. 加载数据</span></div><div class="line">                <span class="comment">//2. 更新UI</span></div><div class="line">                <span class="comment">//3. mIsInited = true</span></div><div class="line">            &#125;</div><div class="line">        &#125;.start();</div><div class="line">    &#125;   </div><div class="line">   </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserVisibleHint</span><span class="params">(<span class="keyword">boolean</span> isVisibleToUser)</span> </span>&#123; </div><div class="line">           <span class="keyword">super</span>.setUserVisibleHint(isVisibleToUser);</div><div class="line">            <span class="keyword">if</span> (isVisibleToUser) &#123;</div><div class="line">            lazyLoad();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyFragment <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> LazyFragment();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Fragment中有两个变量控制是否需要做数据加载：</p>
<ol>
<li>mIsPrepared：表示UI是否准备好，因为数据加载后需要更新UI，如果UI还没有inflate，就不需要做数据加载，因为setUserVisibleHint()会在onCreateView()之前调用一次，如果此时调用，UI还没有inflate，因此不能加载数据。</li>
<li>mIsInited：表示是否已经做过数据加载，如果做过了就不需要做了。因为setUserVisibleHint(true)在界面可见时都会调用，如果滑到该界面做过数据加载后，滑走，再滑回来，还是会调用setUserVisibleHint(true)，此时由于mIsInited=true，因此不会再做一遍数据加载。</li>
<li>lazyLoad()：懒加载的核心类，在该方法中，只有界面可见（getUserVisibleHint()==true）、UI准备好（mIsPrepared==true）<br>过去没做过数据加载（mIsInited==false）时，才需要调loadData()做数据加载，数据加载做完后把mIsInited置为true。</li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2018/03/08/Android-设计模式-观察者模式/" class="prev">PREV</a><a href="/2017/12/03/Android-okhttp的基本用法/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">dangxy</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>